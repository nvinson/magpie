diff --git a/docs/grub.texi b/docs/grub.texi
index e935af33e..289b202df 100644
--- a/docs/grub.texi
+++ b/docs/grub.texi
@@ -1405,6 +1405,19 @@ the Linux kernel, using a @samp{root=UUID=...} kernel parameter.  This is
 usually more reliable, but in some cases it may not be appropriate.  To
 disable the use of UUIDs, set this option to @samp{true}.
 
+@item GRUB_ENABLE_LINUX_PARTUUID
+Normally, when @command{grub-mkconfig} sets the @samp{root=UUID=...} kernel
+parameter, it selects a filesystem UUID.  This works well for Linux systems that
+boot using an initramfs as most implementations support mounting the root
+filesystem this way.  However for Linux systems that do not boot using an
+initramfs, @command{grub-mkconfig} defaults to setting the @samp{root=...}
+kernel parameter to the device name containing the root filesystem.  Setting
+this option to @samp{true} changes the behavior of @command{grub-mkconfig} so
+that it identifies the device containing the root filesystem by the partition
+UUID.  In order to use the @samp{root=PARTUUID=...} kernel parameter, the Linux
+kernel version must be at least 2.6.37 (3.10 for systems using the MSDOS
+partition scheme).
+
 @item GRUB_DISABLE_RECOVERY
 If this option is set to @samp{true}, disable the generation of recovery
 mode menu entries.
diff --git a/grub-core/commands/probe.c b/grub-core/commands/probe.c
index cf2793e1d..d58ee89aa 100644
--- a/grub-core/commands/probe.c
+++ b/grub-core/commands/probe.c
@@ -24,6 +24,8 @@
 #include <grub/device.h>
 #include <grub/disk.h>
 #include <grub/partition.h>
+#include <grub/gpt_partition.h>
+#include <grub/i386/pc/boot.h>
 #include <grub/net.h>
 #include <grub/fs.h>
 #include <grub/file.h>
@@ -45,9 +47,25 @@ static const struct grub_arg_option options[] =
     {"fs",		'f', 0, N_("Determine filesystem type."), 0, 0},
     {"fs-uuid",		'u', 0, N_("Determine filesystem UUID."), 0, 0},
     {"label",		'l', 0, N_("Determine filesystem label."), 0, 0},
+    /* GUID but Linux kernel calls it "PARTUUID" */
+    {"partuuid",	'g', 0, N_("Determine partition GUID/UUID."), 0, 0},
     {0, 0, 0, 0, 0, 0}
   };
 
+static char *
+sprint_gpt_guid (grub_gpt_part_guid_t guid)
+{
+  guid.data1 = grub_le_to_cpu32 (guid.data1);
+  guid.data2 = grub_le_to_cpu16 (guid.data2);
+  guid.data3 = grub_le_to_cpu16 (guid.data3);
+
+  return grub_xasprintf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+			 guid.data1, guid.data2, guid.data3, guid.data4[0],
+			 guid.data4[1], guid.data4[2], guid.data4[3],
+			 guid.data4[4], guid.data4[5], guid.data4[6],
+			 guid.data4[7]);
+}
+
 static grub_err_t
 grub_cmd_probe (grub_extcmd_context_t ctxt, int argc, char **args)
 {
@@ -154,6 +172,66 @@ grub_cmd_probe (grub_extcmd_context_t ctxt, int argc, char **args)
       grub_device_close (dev);
       return GRUB_ERR_NONE;
     }
+  if (state[6].set)
+    {
+      char *partuuid = NULL; /* NULL to silence a spurious GCC warning */
+      /*
+       * Nested partitions are not supported for now.
+       * Non-nested partitions must have dev->disk->partition->parent == NULL
+       */
+      if (dev->disk && dev->disk->partition
+	  && dev->disk->partition->parent == NULL)
+       {
+	 grub_partition_t p = dev->disk->partition;
+	 if (grub_strcmp (p->partmap->name, "msdos") == 0)
+	   {
+	     /*
+	      * The partition GUID for MSDOS is the partition number (starting
+	      * with 1) prepended with the NT disk signature.
+	      */
+	     dev->disk->partition = p->parent;
+	     grub_uint32_t nt_disk_sig;
+	     err = grub_disk_read (dev->disk, 0,
+				   GRUB_BOOT_MACHINE_WINDOWS_NT_MAGIC,
+				   sizeof(nt_disk_sig), &nt_disk_sig);
+	     dev->disk->partition = p;
+	     if (err)
+	       return grub_errno;
+	     /* partition numbers are one-based */
+	     partuuid = grub_xasprintf ("%08x-%02x",
+					grub_le_to_cpu32(nt_disk_sig),
+					p->number + 1);
+	   }
+	 else if (grub_strcmp (p->partmap->name, "gpt") == 0)
+	   {
+	     struct grub_gpt_partentry gptdata;
+
+	     dev->disk->partition = p->parent;
+	     err = grub_disk_read (dev->disk, p->offset, p->index,
+				   sizeof gptdata, &gptdata);
+	     dev->disk->partition = p;
+	     if (err)
+	       return grub_errno;
+
+	     partuuid = sprint_gpt_guid(gptdata.guid);
+	   }
+	 else
+	   return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+			      N_("partition map %s does not support "
+				 "partition UUIDs"),
+			      dev->disk->partition->partmap->name);
+       }
+      else
+       partuuid = grub_strdup (""); /* a freeable empty string */
+
+      if (state[0].set)
+	grub_env_set (state[0].arg, partuuid);
+      else
+	grub_printf ("%s", partuuid);
+      grub_free (partuuid);
+      grub_device_close (dev);
+      return GRUB_ERR_NONE;
+    }
   grub_device_close (dev);
   return grub_error (GRUB_ERR_BAD_ARGUMENT, "unrecognised target");
 }
diff --git a/grub-core/disk/ldm.c b/grub-core/disk/ldm.c
index 0f978ad05..2a22d2d6c 100644
--- a/grub-core/disk/ldm.c
+++ b/grub-core/disk/ldm.c
@@ -135,7 +135,7 @@ msdos_has_ldm_partition (grub_disk_t dsk)
   return has_ldm;
 }
 
-static const grub_gpt_part_type_t ldm_type = GRUB_GPT_PARTITION_TYPE_LDM;
+static const grub_gpt_part_guid_t ldm_type = GRUB_GPT_PARTITION_TYPE_LDM;
 
 /* Helper for gpt_ldm_sector.  */
 static int
diff --git a/grub-core/partmap/gpt.c b/grub-core/partmap/gpt.c
index 83bcba779..103f6796f 100644
--- a/grub-core/partmap/gpt.c
+++ b/grub-core/partmap/gpt.c
@@ -33,10 +33,10 @@ static grub_uint8_t grub_gpt_magic[8] =
     0x45, 0x46, 0x49, 0x20, 0x50, 0x41, 0x52, 0x54
   };
 
-static const grub_gpt_part_type_t grub_gpt_partition_type_empty = GRUB_GPT_PARTITION_TYPE_EMPTY;
+static const grub_gpt_part_guid_t grub_gpt_partition_type_empty = GRUB_GPT_PARTITION_TYPE_EMPTY;
 
 #ifdef GRUB_UTIL
-static const grub_gpt_part_type_t grub_gpt_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
+static const grub_gpt_part_guid_t grub_gpt_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
 #endif
 
 /* 512 << 7 = 65536 byte sectors.  */
diff --git a/grub-core/script/yylex.l b/grub-core/script/yylex.l
index 95b219170..3917904b4 100644
--- a/grub-core/script/yylex.l
+++ b/grub-core/script/yylex.l
@@ -31,10 +31,6 @@
 #pragma GCC diagnostic ignored "-Wunused-function"
 #pragma GCC diagnostic ignored "-Wsign-compare"
 
-#define yyalloc(size, scanner)   (grub_malloc((size)))
-#define yyfree(ptr, scanner)   (grub_free((ptr)))
-#define yyrealloc(ptr, size, scanner) (grub_realloc((ptr), (size)))
-
 /* 
  * As we don't have access to yyscanner, we cannot do much except to
  * print the fatal error.
@@ -327,6 +323,24 @@ POS_MULTILINE   {WORD}?\\\n
                 }
 %%
 
+void *
+yyalloc(yy_size_t size, yyscan_t yyscanner)
+{
+  return grub_malloc(size);
+}
+
+void
+yyfree(void *ptr, yyscan_t yyscanner)
+{
+  return grub_free(ptr);
+}
+
+void *
+yyrealloc(void *ptr, yy_size_t size, yyscan_t yyscanner)
+{
+  return grub_realloc(ptr, size);
+}
+
 int
 yywrap (yyscan_t yyscanner)
 {
diff --git a/include/grub/gpt_partition.h b/include/grub/gpt_partition.h
index 1b32f6725..354fe2246 100644
--- a/include/grub/gpt_partition.h
+++ b/include/grub/gpt_partition.h
@@ -22,14 +22,14 @@
 #include <grub/types.h>
 #include <grub/partition.h>
 
-struct grub_gpt_part_type
+struct grub_gpt_part_guid
 {
   grub_uint32_t data1;
   grub_uint16_t data2;
   grub_uint16_t data3;
   grub_uint8_t data4[8];
 } __attribute__ ((aligned(8)));
-typedef struct grub_gpt_part_type grub_gpt_part_type_t;
+typedef struct grub_gpt_part_guid grub_gpt_part_guid_t;
 
 #define GRUB_GPT_PARTITION_TYPE_EMPTY \
   { 0x0, 0x0, 0x0, \
@@ -70,8 +70,8 @@ struct grub_gpt_header
 
 struct grub_gpt_partentry
 {
-  grub_gpt_part_type_t type;
-  grub_uint8_t guid[16];
+  grub_gpt_part_guid_t type;
+  grub_gpt_part_guid_t guid;
   grub_uint64_t start;
   grub_uint64_t end;
   grub_uint64_t attrib;
diff --git a/util/grub-install.c b/util/grub-install.c
index 6c89c2b0c..23b0acb50 100644
--- a/util/grub-install.c
+++ b/util/grub-install.c
@@ -713,7 +713,7 @@ is_prep_partition (grub_device_t dev)
       if (grub_disk_read (dev->disk, p->offset, p->index,
 			  sizeof (gptdata), &gptdata) == 0)
 	{
-	  const grub_gpt_part_type_t template = {
+	  const grub_gpt_part_guid_t template = {
 	    grub_cpu_to_le32_compile_time (0x9e1a2d38),
 	    grub_cpu_to_le16_compile_time (0xc612),
 	    grub_cpu_to_le16_compile_time (0x4316),
diff --git a/util/grub-mkconfig.in b/util/grub-mkconfig.in
index f8496d28b..30ead59e1 100644
--- a/util/grub-mkconfig.in
+++ b/util/grub-mkconfig.in
@@ -134,6 +134,7 @@ fi
 # Device containing our userland.  Typically used for root= parameter.
 GRUB_DEVICE="`${grub_probe} --target=device /`"
 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
+GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
 
 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
@@ -182,6 +183,7 @@ if [ "x${GRUB_ACTUAL_DEFAULT}" = "xsaved" ] ; then GRUB_ACTUAL_DEFAULT="`"${grub
 # override them.
 export GRUB_DEVICE \
   GRUB_DEVICE_UUID \
+  GRUB_DEVICE_PARTUUID \
   GRUB_DEVICE_BOOT \
   GRUB_DEVICE_BOOT_UUID \
   GRUB_FS \
@@ -215,6 +217,7 @@ export GRUB_DEFAULT \
   GRUB_TERMINAL_OUTPUT \
   GRUB_SERIAL_COMMAND \
   GRUB_DISABLE_LINUX_UUID \
+  GRUB_ENABLE_LINUX_PARTUUID \
   GRUB_DISABLE_RECOVERY \
   GRUB_VIDEO_BACKEND \
   GRUB_GFXMODE \
diff --git a/util/grub-probe.c b/util/grub-probe.c
index 8ac527d2f..3656e32e8 100644
--- a/util/grub-probe.c
+++ b/util/grub-probe.c
@@ -28,6 +28,7 @@
 #include <grub/partition.h>
 #include <grub/msdos_partition.h>
 #include <grub/gpt_partition.h>
+#include <grub/i386/pc/boot.h>
 #include <grub/emu/hostdisk.h>
 #include <grub/emu/getroot.h>
 #include <grub/term.h>
@@ -62,6 +63,7 @@ enum {
   PRINT_DRIVE,
   PRINT_DEVICE,
   PRINT_PARTMAP,
+  PRINT_PARTUUID,
   PRINT_ABSTRACTION,
   PRINT_CRYPTODISK_UUID,
   PRINT_HINT_STR,
@@ -85,6 +87,7 @@ static const char *targets[] =
     [PRINT_DRIVE]              = "drive",
     [PRINT_DEVICE]             = "device",
     [PRINT_PARTMAP]            = "partmap",
+    [PRINT_PARTUUID]           = "partuuid",
     [PRINT_ABSTRACTION]        = "abstraction",
     [PRINT_CRYPTODISK_UUID]    = "cryptodisk_uuid",
     [PRINT_HINT_STR]           = "hints_string",
@@ -129,6 +132,20 @@ get_targets_string (void)
   return str;
 }
 
+static int
+print_gpt_guid (grub_gpt_part_guid_t guid)
+{
+  guid.data1 = grub_le_to_cpu32 (guid.data1);
+  guid.data2 = grub_le_to_cpu16 (guid.data2);
+  guid.data3 = grub_le_to_cpu16 (guid.data3);
+
+  return grub_printf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		      guid.data1, guid.data2, guid.data3, guid.data4[0],
+		      guid.data4[1], guid.data4[2], guid.data4[3],
+		      guid.data4[4], guid.data4[5], guid.data4[6],
+		      guid.data4[7]);
+}
+
 static void
 do_print (const char *x, void *data)
 {
@@ -168,6 +185,48 @@ probe_partmap (grub_disk_t disk, char delim)
 }
 
 static void
+probe_partuuid (grub_disk_t disk, char delim)
+{
+  /*
+   * Nested partitions not supported for now.
+   * Non-nested partitions must have disk->partition->parent == NULL
+   */
+  if (disk->partition && disk->partition->parent == NULL)
+    {
+      if (strcmp(disk->partition->partmap->name, "msdos") == 0)
+	{
+	    /*
+	     * The partition GUID for MSDOS is the partition number (starting
+	     * with 1) prepended with the NT disk signature.
+	     */
+            grub_uint32_t nt_disk_sig;
+	    grub_partition_t p = disk->partition;
+	    disk->partition = p->parent;
+
+	    if (grub_disk_read (disk, 0, GRUB_BOOT_MACHINE_WINDOWS_NT_MAGIC,
+				sizeof(nt_disk_sig), &nt_disk_sig) == 0)
+	      {
+		grub_printf ("%08x-%02x",
+			     grub_le_to_cpu32(nt_disk_sig), 1 + p->number);
+	      }
+	    disk->partition = p;
+	}
+      else if (strcmp(disk->partition->partmap->name, "gpt") == 0)
+	{
+	  grub_partition_t p = disk->partition;
+	  struct grub_gpt_partentry gptdata;
+
+	  disk->partition = p->parent;
+
+	  if (grub_disk_read (disk, p->offset, p->index,
+			      sizeof(gptdata), &gptdata) == 0)
+	    print_gpt_guid(gptdata.guid);
+	  disk->partition = p;
+	}
+    }
+}
+
+static void
 probe_cryptodisk_uuid (grub_disk_t disk, char delim)
 {
   grub_disk_memberlist_t list = NULL, tmp;
@@ -621,6 +680,12 @@ probe (const char *path, char **device_names, char delim)
 	/* Check if dev->disk itself is contained in a partmap.  */
 	probe_partmap (dev->disk, delim);
 
+      else if (print == PRINT_PARTUUID)
+	{
+	  probe_partuuid (dev->disk, delim);
+	  putchar (delim);
+	}
+
       else if (print == PRINT_MSDOS_PARTTYPE)
 	{
 	  if (dev->disk->partition
@@ -641,21 +706,7 @@ probe (const char *path, char **device_names, char delim)
 
               if (grub_disk_read (dev->disk, p->offset, p->index,
                                   sizeof (gptdata), &gptdata) == 0)
-                {
-                  grub_gpt_part_type_t gpttype;
-                  gpttype.data1 = grub_le_to_cpu32 (gptdata.type.data1);
-                  gpttype.data2 = grub_le_to_cpu16 (gptdata.type.data2);
-                  gpttype.data3 = grub_le_to_cpu16 (gptdata.type.data3);
-                  grub_memcpy (gpttype.data4, gptdata.type.data4, 8);
-
-                  grub_printf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-                               gpttype.data1, gpttype.data2,
-                               gpttype.data3, gpttype.data4[0], 
-                               gpttype.data4[1], gpttype.data4[2],
-                               gpttype.data4[3], gpttype.data4[4],
-                               gpttype.data4[5], gpttype.data4[6],
-                               gpttype.data4[7]);
-                }
+		print_gpt_guid(gptdata.type);
               dev->disk->partition = p;
             }
           putchar (delim);
diff --git a/util/grub.d/10_linux.in b/util/grub.d/10_linux.in
index de9044c7f..71675fac6 100644
--- a/util/grub.d/10_linux.in
+++ b/util/grub.d/10_linux.in
@@ -220,8 +220,17 @@ while [ "x$list" != "x" ] ; do
     gettext_printf "Found initrd image: %s\n" "${dirname}/${initrd}" >&2
   elif test -z "${initramfs}" ; then
     # "UUID=" and "ZFS=" magic is parsed by initrd or initramfs.  Since there's
-    # no initrd or builtin initramfs, it can't work here.
-    linux_root_device_thisversion=${GRUB_DEVICE}
+    # no initrd or builtin initramfs, it can't work here.  However, if
+    # GRUB_DEVICE_PARTUUID is not empty we can use that here if
+    # GRUD_DISABLE_LINUX_UUID is not set to true and GRUB_ENABLE_LINUX_PARTUUID
+    # is set to true.
+    if [ "x${GRUB_DISABLE_LINUX_UUID}" != "xtrue" ] \
+        && [ "x${GRUB_DEVICE_PARTUUID}" != "x" ]    \
+        && [ "x${GRUB_ENABLE_LINUX_PARTUUID}" = "xtrue" ] ; then
+        linux_root_device_thisversion="PARTUUID=${GRUB_DEVICE_PARTUUID}"
+    else
+        linux_root_device_thisversion=${GRUB_DEVICE}
+    fi
   fi
 
   if [ "x$is_top_level" = xtrue ] && [ "x${GRUB_DISABLE_SUBMENU}" != xy ]; then
