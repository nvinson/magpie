diff --git a/docs/grub.texi b/docs/grub.texi
index 82f6fa4..1f312c6 100644
--- a/docs/grub.texi
+++ b/docs/grub.texi
@@ -1405,6 +1405,19 @@ the Linux kernel, using a @samp{root=UUID=...} kernel parameter.  This is
 usually more reliable, but in some cases it may not be appropriate.  To
 disable the use of UUIDs, set this option to @samp{true}.
 
+@item GRUB_ENABLE_LINUX_PARTUUID
+Normally, when @command{grub-mkconfig} sets the @samp{root=UUID=...} kernel
+parameter, it selects a filesystem UUID.  This works well for Linux systems that
+boot using an initramfs as most implementations support mounting the root
+filesystem this way.  However for Linux systems that do not boot using an
+initramfs, @command{grub-mkconfig} defaults to setting the @samp{root=...}
+kernel parameter to the device name containing the root filesystem.  Setting
+this option to @samp{true} changes the behavior of @command{grub-mkconfig} so
+that it identifies the device containing the root filesystem by the partition
+UUID.  In order to use the @samp{root=PARTUUID=...} kernel parameter, the Linux
+kernel version must be at least 2.6.37 (3.10 for systems using the MSDOS
+partition scheme).
+
 @item GRUB_DISABLE_RECOVERY
 If this option is set to @samp{true}, disable the generation of recovery
 mode menu entries.
diff --git a/util/grub-mkconfig.in b/util/grub-mkconfig.in
index f8496d2..30ead59 100644
--- a/util/grub-mkconfig.in
+++ b/util/grub-mkconfig.in
@@ -134,6 +134,7 @@ fi
 # Device containing our userland.  Typically used for root= parameter.
 GRUB_DEVICE="`${grub_probe} --target=device /`"
 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
+GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
 
 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
@@ -182,6 +183,7 @@ if [ "x${GRUB_ACTUAL_DEFAULT}" = "xsaved" ] ; then GRUB_ACTUAL_DEFAULT="`"${grub
 # override them.
 export GRUB_DEVICE \
   GRUB_DEVICE_UUID \
+  GRUB_DEVICE_PARTUUID \
   GRUB_DEVICE_BOOT \
   GRUB_DEVICE_BOOT_UUID \
   GRUB_FS \
@@ -215,6 +217,7 @@ export GRUB_DEFAULT \
   GRUB_TERMINAL_OUTPUT \
   GRUB_SERIAL_COMMAND \
   GRUB_DISABLE_LINUX_UUID \
+  GRUB_ENABLE_LINUX_PARTUUID \
   GRUB_DISABLE_RECOVERY \
   GRUB_VIDEO_BACKEND \
   GRUB_GFXMODE \
diff --git a/util/grub-probe.c b/util/grub-probe.c
index 8ac527d..97daac6 100644
--- a/util/grub-probe.c
+++ b/util/grub-probe.c
@@ -62,6 +62,7 @@ enum {
   PRINT_DRIVE,
   PRINT_DEVICE,
   PRINT_PARTMAP,
+  PRINT_PARTUUID,
   PRINT_ABSTRACTION,
   PRINT_CRYPTODISK_UUID,
   PRINT_HINT_STR,
@@ -85,6 +86,7 @@ static const char *targets[] =
     [PRINT_DRIVE]              = "drive",
     [PRINT_DEVICE]             = "device",
     [PRINT_PARTMAP]            = "partmap",
+    [PRINT_PARTUUID]           = "partuuid",
     [PRINT_ABSTRACTION]        = "abstraction",
     [PRINT_CRYPTODISK_UUID]    = "cryptodisk_uuid",
     [PRINT_HINT_STR]           = "hints_string",
@@ -168,6 +170,65 @@ probe_partmap (grub_disk_t disk, char delim)
 }
 
 static void
+print_gpt_guid(const struct grub_gpt_partentry gptdata)
+{
+  grub_gpt_part_type_t gpttype;
+  gpttype.data1 = grub_le_to_cpu32 (gptdata.type.data1);
+  gpttype.data2 = grub_le_to_cpu16 (gptdata.type.data2);
+  gpttype.data3 = grub_le_to_cpu16 (gptdata.type.data3);
+  grub_memcpy (gpttype.data4, gptdata.type.data4, 8);
+
+  grub_printf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+	       gpttype.data1, gpttype.data2, gpttype.data3, gpttype.data4[0],
+	       gpttype.data4[1], gpttype.data4[2], gpttype.data4[3],
+	       gpttype.data4[4], gpttype.data4[5], gpttype.data4[6],
+	       gpttype.data4[7]);
+}
+
+static void
+probe_partuuid (grub_disk_t disk, char delim)
+{
+  if (disk->partition)
+    {
+      if (strcmp(disk->partition->partmap->name, "gpt") == 0)
+	{
+	  const int guid_offset = 16;
+
+	  grub_partition_t p = disk->partition;
+	  struct grub_gpt_partentry gptdata;
+
+	  disk->partition = p->parent;
+
+	  if (grub_disk_read (disk, p->offset, p->index + guid_offset,
+			      sizeof(gptdata), &gptdata) == 0)
+	    print_gpt_guid (gptdata);
+
+	  disk->partition = p;
+	}
+      else if (strcmp(disk->partition->partmap->name, "msdos") == 0)
+	{
+	    /*
+	     * The partition GUID for MSDOS is the partition number (starting
+	     * with 1) prepended with the NT disk signature.
+	     */
+	    const int nt_disk_sig_offset = 440;
+	    grub_uint32_t nt_disk_sig;
+	    grub_partition_t p = disk->partition;
+
+	    disk->partition = p->parent;
+
+	    if (grub_disk_read (disk, 0, nt_disk_sig_offset, sizeof(nt_disk_sig),
+				&nt_disk_sig) == 0)
+	      {
+		nt_disk_sig = grub_le_to_cpu32(nt_disk_sig);
+		grub_printf ("%08x-%02x", nt_disk_sig, 1 + p->number);
+	      }
+	    disk->partition = p;
+	}
+    }
+}
+
+static void
 probe_cryptodisk_uuid (grub_disk_t disk, char delim)
 {
   grub_disk_memberlist_t list = NULL, tmp;
@@ -621,6 +682,12 @@ probe (const char *path, char **device_names, char delim)
 	/* Check if dev->disk itself is contained in a partmap.  */
 	probe_partmap (dev->disk, delim);
 
+      else if (print == PRINT_PARTUUID)
+	{
+	  probe_partuuid (dev->disk, delim);
+	  putchar (delim);
+	}
+
       else if (print == PRINT_MSDOS_PARTTYPE)
 	{
 	  if (dev->disk->partition
@@ -641,21 +708,7 @@ probe (const char *path, char **device_names, char delim)
 
               if (grub_disk_read (dev->disk, p->offset, p->index,
                                   sizeof (gptdata), &gptdata) == 0)
-                {
-                  grub_gpt_part_type_t gpttype;
-                  gpttype.data1 = grub_le_to_cpu32 (gptdata.type.data1);
-                  gpttype.data2 = grub_le_to_cpu16 (gptdata.type.data2);
-                  gpttype.data3 = grub_le_to_cpu16 (gptdata.type.data3);
-                  grub_memcpy (gpttype.data4, gptdata.type.data4, 8);
-
-                  grub_printf ("%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-                               gpttype.data1, gpttype.data2,
-                               gpttype.data3, gpttype.data4[0], 
-                               gpttype.data4[1], gpttype.data4[2],
-                               gpttype.data4[3], gpttype.data4[4],
-                               gpttype.data4[5], gpttype.data4[6],
-                               gpttype.data4[7]);
-                }
+		print_gpt_guid(gptdata);
               dev->disk->partition = p;
             }
           putchar (delim);
diff --git a/util/grub.d/10_linux.in b/util/grub.d/10_linux.in
index de9044c..71675fa 100644
--- a/util/grub.d/10_linux.in
+++ b/util/grub.d/10_linux.in
@@ -220,8 +220,17 @@ while [ "x$list" != "x" ] ; do
     gettext_printf "Found initrd image: %s\n" "${dirname}/${initrd}" >&2
   elif test -z "${initramfs}" ; then
     # "UUID=" and "ZFS=" magic is parsed by initrd or initramfs.  Since there's
-    # no initrd or builtin initramfs, it can't work here.
-    linux_root_device_thisversion=${GRUB_DEVICE}
+    # no initrd or builtin initramfs, it can't work here.  However, if
+    # GRUB_DEVICE_PARTUUID is not empty we can use that here if
+    # GRUD_DISABLE_LINUX_UUID is not set to true and GRUB_ENABLE_LINUX_PARTUUID
+    # is set to true.
+    if [ "x${GRUB_DISABLE_LINUX_UUID}" != "xtrue" ] \
+        && [ "x${GRUB_DEVICE_PARTUUID}" != "x" ]    \
+        && [ "x${GRUB_ENABLE_LINUX_PARTUUID}" = "xtrue" ] ; then
+        linux_root_device_thisversion="PARTUUID=${GRUB_DEVICE_PARTUUID}"
+    else
+        linux_root_device_thisversion=${GRUB_DEVICE}
+    fi
   fi
 
   if [ "x$is_top_level" = xtrue ] && [ "x${GRUB_DISABLE_SUBMENU}" != xy ]; then
